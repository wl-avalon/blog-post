---
title: MySQL原理：1. 初窥InnoDB存储引擎索引
date: 2019-10-29
updated: 2019-10-30
tags:
 - mysql
 - innoDB
 - 索引
categories:
 - 技术沉淀

---

&emsp;&emsp;最近出去面试了几家小公司，虽然基本都过了，不过很多问题都是用一年前看过书但是时间一长就忘了，只答了一个轮廓，没有一年前那么透彻了。然后偷看到一个面试评价写的是项目经历一般，基础知识一般QAQ……<br>&emsp;&emsp;哼！气煞老夫。看来还是要亲自动手做记录，学到的知识才能比较成体系。那就先立个flag，按顺序开三个系列吧，分别探讨一下MySQL、Redis、GoLang这三个东西的各种底层实现机制以及设计思路。<br>&emsp;&emsp;呐，现在就从MySQL开始。梳理一下相关的各种知识。<!-- more -->

---------------------

# 什么是索引

&emsp;&emsp;开始讲索引的各种底层实现以及设计思路之前，必须先搞明白索引的使用场景以及实际作用，根据具体的使用场景才能反推出索引的底层实现为什么是这样，而不是那样实现。有些使用场景应该这么用索引，同样的用法在其他一些场景反而会导致问题。<br>&emsp;&emsp;众所周知，MySQL使用InnoDB作为存储引擎时，所有存在MySQL的数据，实际都是由InnoDB负责存储的。如今大互联网时代，各大公司的数据量越来越大，InnoDB中存的数据也越来越多。比如滴滴的乘客数据，假设一开始只有100个乘客在用滴滴，乘客数据存在一个数组里，在当张三打开APP登陆时，需要查询到这个用户信息，最简单的方法就是一个for循环，把这个乘客数组遍历一遍，然后找到姓名等于张三的这个乘客的信息。当滴滴的业务开始井喷增长，乘客数量上亿时，当乘客打开APP时查询用户数据如果仍然遍历长度上亿的乘客数组，找到这个乘客，那就需要遍历上亿条数据。上亿用户同时登陆，每个用户查询数据时都遍历上亿次，这谁顶得住啊。<br>&emsp;&emsp;因此为了优化查询效率，我们就会思考既然每个乘客的数据都有各自的特殊性，比如姓名、年龄、生日、性别等等。那假如我们建立一个Map，以姓名为key，对应的value为乘客数据的一个数组，然后将姓名相同的乘客，都放入对应的key里。这样，当张三打开APP再次查询用户信息时，我们就可以根据“张三”这个key，从哈希表中查出一个用户列表，这个列表里所有的乘客姓名都叫张三。虽然叫张三的人可能很多，但是至少不再用遍历上亿条的数据了，只需要从这一堆都叫“张三”的乘客里，找到自己真正想要的数据即可。<br>&emsp;&emsp;在上面这个例子中，“姓名”这个属性就可以称为“乘客数据”这种数据的索引，这个索引的底层实现是Map。因为根据“姓名”这个属性，我们可以更快找到想要的数据。<br>&emsp;&emsp;所以可以看出，<font color = #bb505d>设计索引的最根本目的就是将某类数据项以一种特殊的数据结构存储，使用这种数据结构查询时，可以增加数据查询效率，而不需要每次都要遍历所有数据才能找到对应的数据。</font><br>&emsp;&emsp;但是上面这个例子中如果我们用性别来建立Map，以性别为key，对应的value为乘客数据的一个数组，那这个Map只会有“男”/“女”这两个Key，每个元素是一个几千万长度的用户数据数组。“张三”想要找到自己的数据，需要遍历几千万的数据，这个计算量仍然是无法接受的。<font color = #bb505d>因此能根据业务场景从各种数据项中找到“辨识度”高的数据项，是设置一个好索引的必要条件。</font>

# 索引的种类

&emsp;&emsp;为了优化各类业务需求的查询效率，为索引提供的各种底层数据结构也是层出不穷，针对不同的业务场景，不同的数据结构也会有显著的优劣势。比较有名的诸如：B+树/哈希表/B-树/红黑树等等。